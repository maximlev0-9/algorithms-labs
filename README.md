# algorithms-labs
Lab 4:
Код запускається через тести в класі CountMinNumberOfPartsTest.
Тестові дані знаходяться в файлах у папці lab4/test_files

Завдання:
Фантазери
Борби Антін та Орі придумали гру - вигадувати випадкові двійкові числа, і перевіряти,
чи ці числа можна розбити на шматки, кожен з яких є степенем числа X у десятковій
системі.
Наприклад, якщо X == 5, то двійкове число число 101110011 можна розбити на 101,
11001 та 1, кожне з яких є 5 у якомусь степені (101 у десятковій == 5 == 5^1, 11001 ==
25 == 5^2 та 1 == 1 - це 5^0).
Продемонструйте, що люди розумніші за бобрів, і для заданого двійкового числа N
знайдіть найменшу кількість шматків, на які його треба розбивати.
\
Вхідні дані:
Перший рядок містить X - послідовність нуликів та одиничок та N.
\
Вихідні дані:
Найменша кількість шматків, на які можемо розбити вхідне число, або -1 якщо
це не можливо.

Обмеження:
\
0 < len(X) < 100
\
0 < N < 100

Приклади:
\
In:
101101101 5
Out:
3
(Можна розбити на 101, 101, 101)
\
In:
1111101 5
Out:
1
(1111101 - це 5^3)
\
In:
110011011 5
Out:
3
(11001, 101, 1)
\
In:
1001110111101001001111101100111001010001111001011100100011001110111101001001
11110110011100101000110010110000111100101110010001 7
Out:
5

Опис алгоритму:
Суть алгоритму в тому, що я спочатку генерую список всіх можливих підстрічок,
які є степенями заданого числа N, у бінарному вигляді. (далі - listOfPossibleSubstrings)

Потім проходжу по всіх елементах заданої бінарної стрічки (далі - binaryStr), і
вкладеним циклом ще проходжу по всіх підстрічках з listOfPossibleSubstrings.

Алгоритм перевіряє, чи до даного елемента можна дойти якимись з підстрічок, і якщо можна, то відповідно, що для того, щоб дойти до даного елемента, треба спочатку дойти до того, з якого починається підстрінга, яка закінчиться саме на даному елементі, але на один крок далі, тобто + 1

Для цього спочатку є перевірки на те, чи в такому випадку індекс, з якого почнеться рахунок, не буде менший за 0, а також, чи взагалі є шлях до елемента, з якого почне рахуватись current підстрічка. 


Приклад з input даними: "10100101001010100" 2

listOfPossibleSubstrings буде містити значення 2^0, 2^1, 2^2, 2^3..., але в бінарному представленні: "1", "10", "100"...

Спочатку, коли i буде рівне нулю, цикл просто пропуститься, бо щоб дійти до нульового елемента, треба буде почати з -1, а такого індексу не існує
(в моєму алгоритмі, дійти до елемента означає знайти стрічки, які співпадуть з усіма елементами до даного, НЕ включаючи)

Потім, (i==1), в циклі з підстрічками перша стрічка ("1") нам підійде (адже, щоб дійти до елемента з індексом 1, потрібно знайти стрічку, яка співпаде з фрагментом до цього індексу, тобто якраз "1"), відповідно, щоб добратись до елемента під індексом 1, треба буде зробити 0+1=1 крок.
На наступній ітерації циклу з підстрічками він перерветься.

Потім, при і==2, перша підстрічка не пройде, бо відповідний їй фрагмент з binaryStr буде рівним "0".
Зате наступна підстрічка ("10") підійде, бо вона співпаде з першими двома елементами binaryStr. Таким чином, шлях до елемента під індексом 2 буде рівним 0+1=1.

Шлях до 3 елемента буде рівним шляху до другого +1 (адже в нас буде підходяща підстрічка "1", щоб пройти частину від 2 до 3 елемента), і тд.

Зрештою, в останньому елементі масиву цих довжин/значень буде знаходитись найменша кількість стрічок, які необхідні, щоб пройти всю стрічку. Якщо такої послідовності не буде, тоді виведеться значення Integer.MAX_VALUE, яке там стоїть по замовчуванню.
